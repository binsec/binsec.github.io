---
layout: post
title:  "ASE '19: extended abstract"
date:   2019-11-06
categories: conference paper abstract
paper-title: "Get rid of inline assembly through verification-oriented lifting"
topic: "Automatic analysis of C & inline assembly;
        Precise decompilation of inline assembly"
pdf: https://arxiv.org/pdf/1903.06407.pdf
---


## Motivation

Have you ever seen this kind of code?

```c
# 76 "ffmpeg/libavcodec/x86/mathops.h"
static inline int mid_pred(int a, int b, int c)
{
    int i=b;
    __asm__ (
        "cmp    %2, %1 \n\t"
        "cmovg  %1, %0 \n\t"
        "cmovg  %2, %1 \n\t"
        "cmp    %3, %1 \n\t"
        "cmovl  %3, %1 \n\t"
        "cmp    %1, %0 \n\t"
        "cmovg  %1, %0 \n\t"
        :"+&r"(i), "+&r"(a)
        :"r"(b), "r"(c)
    );
    return i;
}
```

If not, you are lucky!

This little nuisance is the **GNU inline assembly** extension and
allows to embed
assembly instructions into your C program.
A 2018 survey reported that more than **1/4** of trending **GitHub** projects
actually
contain it. On our part, we found it in more than **10%** of
package sources in the **Debian** distribution.

Guess what? State of the art C program analyzers do not like it... not at all!

For instance, the **KLEE** symbolic execution engine stops when it hits
an assembly chunk. **Frama-C** plugins, on the other hand, will pass through,
but will severely over-approximate its behavior.
This leads to either incomplete or imprecise results -- when they are not
simply wrong.

That is why we proposed **TInA** *-- for Taming Inline Assembly --* an automated,
generic, verification-friendly and trustworthy lifting technique such that we can reuse, as is, our favorite C analyzer.

## Contributions

In summary, this paper makes the following contributions:

- A new principled method lifting inline assembly to high-level C amenable to
  further formal analysis;
- The  automated  validation  of  said  method  to  make  the lifter
  trustworthy;
- Thorough  experiments of  a  prototype  implementation  on  real-world
  examples.

Thus,
TInA has been shown to be widely applicable and trustworthy: in less than
**1/2 hour**, it was able to lift **2k** assembly chunks coming from a typical Debian distribution (including **FFMPEG**, **ALSA**, **GMP**, ...) and validate **all** of the lifted code and this, whatever was the compiler
-- **GCC** or **Clang** -- or the architecture -- **x86** or **ARM**.
Last but not least, the produced C code is shown to be well suited for automatic
analysis (for both **KLEE** and **Frama-C**).

## Further information

- Look @ [the **paper**](https://arxiv.org/pdf/1903.06407.pdf)
- Meet us @ [the 34th IEEE/ACM International Conference on **Automated Software Engineering**](https://2019.ase-conferences.org/)